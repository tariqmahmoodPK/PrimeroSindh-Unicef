{"version":3,"file":"post-message.js","sources":["../../node_modules/typeson/utils/TypesonPromise.js","../../node_modules/typeson/utils/classMethods.js","../../node_modules/typeson/typeson.js","../../types/error.js","../../types/errors.js","../../presets/post-message.js"],"sourcesContent":["/**\n * We keep this function minimized so if using two instances of this\n *   library, where one is minimized and one is not, it will still work\n *   with `hasConstructorOf`.\n * With ES6 classes, we may be able to simply use `class TypesonPromise\n *   extends Promise` and add a string tag for detection\n * @param {function} f\n */\nclass TypesonPromise{constructor(f){this.p=new Promise(f)}} // eslint-disable-line block-spacing, space-before-function-paren, space-before-blocks, space-infix-ops, semi\n// class TypesonPromise extends Promise {get[Symbol.toStringTag](){return 'TypesonPromise'};} // eslint-disable-line keyword-spacing, space-before-function-paren, space-before-blocks, block-spacing, semi\n\n// Note: @babel/polyfill provides a `Symbol` polyfill\nif (typeof Symbol !== 'undefined') {\n    // Ensure `isUserObject` will return `false` for `TypesonPromise`\n    TypesonPromise.prototype[Symbol.toStringTag] = 'TypesonPromise';\n}\n\n/**\n *\n * @param {function} [onFulfilled]\n * @param {function} [onRejected]\n * @returns {TypesonPromise}\n */\nTypesonPromise.prototype.then = function (onFulfilled, onRejected) {\n    return new TypesonPromise((typesonResolve, typesonReject) => {\n        this.p.then(function (res) {\n            typesonResolve(onFulfilled ? onFulfilled(res) : res);\n        }, (r) => {\n            this.p['catch'](function (res) {\n                return onRejected ? onRejected(res) : Promise.reject(res);\n            }).then(typesonResolve, typesonReject);\n        });\n    });\n};\n\n/**\n *\n * @param {function} onRejected\n * @returns {TypesonPromise}\n */\nTypesonPromise.prototype.catch = function (onRejected) {\n    return this.then(null, onRejected);\n};\n/**\n *\n * @param {} v\n * @returns {TypesonPromise}\n */\nTypesonPromise.resolve = function (v) {\n    return new TypesonPromise((typesonResolve) => {\n        typesonResolve(v);\n    });\n};\n/**\n *\n * @param {} v\n * @returns {TypesonPromise}\n */\nTypesonPromise.reject = function (v) {\n    return new TypesonPromise((typesonResolve, typesonReject) => {\n        typesonReject(v);\n    });\n};\n['all', 'race'].map(function (meth) {\n    /**\n     *\n     * @param {Promise[]} promArr\n     * @returns {TypesonPromise}\n     */\n    TypesonPromise[meth] = function (promArr) {\n        return new TypesonPromise(function (typesonResolve, typesonReject) {\n            Promise[meth](promArr.map((prom) => {\n                return prom.p;\n            })).then(typesonResolve, typesonReject);\n        });\n    };\n});\n\nexport {TypesonPromise};\n","const {toString} = {},\n    hasOwn = ({}.hasOwnProperty),\n    getProto = Object.getPrototypeOf,\n    fnToString = hasOwn.toString;\n\n/**\n *\n * @param {*} v\n * @param {boolean} catchCheck\n * @returns {boolean}\n */\nfunction isThenable (v, catchCheck) {\n    return isObject(v) &&\n        typeof v.then === 'function' &&\n            (!catchCheck || typeof v.catch === 'function');\n}\n\n/**\n *\n * @param {*} val\n * @returns {string}\n */\nfunction toStringTag (val) {\n    return toString.call(val).slice(8, -1);\n}\n\n/**\n * This function is dependent on both constructors\n *   being identical so any minimization is expected of both.\n * @param {*} a\n * @param {function} b\n * @returns {boolean}\n */\nfunction hasConstructorOf (a, b) {\n    if (!a || typeof a !== 'object') {\n        return false;\n    }\n    const proto = getProto(a);\n    if (!proto) {\n        return false;\n    }\n    const Ctor = hasOwn.call(proto, 'constructor') && proto.constructor;\n    if (typeof Ctor !== 'function') {\n        return b === null;\n    }\n    return typeof Ctor === 'function' && b !== null &&\n        fnToString.call(Ctor) === fnToString.call(b);\n}\n\n/**\n *\n * @param {*} val\n * @returns {boolean}\n */\nfunction isPlainObject (val) { // Mirrors jQuery's\n    if (!val || toStringTag(val) !== 'Object') {\n        return false;\n    }\n\n    const proto = getProto(val);\n    if (!proto) { // `Object.create(null)`\n        return true;\n    }\n\n    return hasConstructorOf(val, Object);\n}\n\n/**\n *\n * @param {*} val\n * @returns {boolean}\n */\nfunction isUserObject (val) {\n    if (!val || toStringTag(val) !== 'Object') {\n        return false;\n    }\n\n    const proto = getProto(val);\n    if (!proto) { // `Object.create(null)`\n        return true;\n    }\n    return hasConstructorOf(val, Object) || isUserObject(proto);\n}\n\n/**\n *\n * @param {*} v\n * @returns {boolean}\n */\nfunction isObject (v) {\n    return v && typeof v === 'object';\n}\n\n/**\n *\n * @param {string} keyPathComponent\n * @returns {string}\n */\nfunction escapeKeyPathComponent (keyPathComponent) {\n    return keyPathComponent.replace(/~/g, '~0').replace(/\\./g, '~1');\n}\n\n/**\n *\n * @param {string} keyPathComponent\n * @returns {string}\n */\nfunction unescapeKeyPathComponent (keyPathComponent) {\n    return keyPathComponent.replace(/~1/g, '.').replace(/~0/g, '~');\n}\n\n/**\n * @param {object|array} obj\n * @param {string} keyPath\n * @returns {*}\n */\nfunction getByKeyPath (obj, keyPath) {\n    if (keyPath === '') {\n        return obj;\n    }\n    const period = keyPath.indexOf('.');\n    if (period > -1) {\n        const innerObj = obj[\n            unescapeKeyPathComponent(keyPath.substr(0, period))\n        ];\n        return innerObj === undefined\n            ? undefined\n            : getByKeyPath(innerObj, keyPath.substr(period + 1));\n    }\n    return obj[unescapeKeyPathComponent(keyPath)];\n}\n\nfunction setAtKeyPath (obj, keyPath, value) {\n    if (keyPath === '') {\n        return value;\n    }\n    const period = keyPath.indexOf('.');\n    if (period > -1) {\n        const innerObj = obj[\n            unescapeKeyPathComponent(keyPath.substr(0, period))\n        ];\n        return setAtKeyPath(innerObj, keyPath.substr(period + 1), value);\n    }\n    obj[unescapeKeyPathComponent(keyPath)] = value;\n    return obj;\n}\n\n/**\n *\n * @param {external:JSON} value\n * @returns {\"null\"|\"array\"|\"undefined\"|\"boolean\"|\"number\"|\"string\"|\"object\"|\"symbol\"}\n */\nfunction getJSONType (value) {\n    return value === null ? 'null' : (\n        Array.isArray(value)\n            ? 'array'\n            : typeof value);\n}\n\nexport {\n    isPlainObject, isObject, isUserObject,\n    hasConstructorOf, isThenable, toStringTag,\n    escapeKeyPathComponent, unescapeKeyPathComponent,\n    getByKeyPath, setAtKeyPath,\n    getJSONType\n};\n","/**\n * Typeson - JSON with types\n * @license The MIT License (MIT)\n * @copyright (c) 2016-2018 David Fahlander, Brett Zamir\n*/\n\nimport {TypesonPromise} from './utils/TypesonPromise.js';\nimport {\n    isPlainObject, isObject, hasConstructorOf,\n    isThenable, toStringTag, isUserObject,\n    escapeKeyPathComponent, unescapeKeyPathComponent,\n    getByKeyPath, setAtKeyPath, getJSONType\n} from './utils/classMethods.js';\n\nconst {keys} = Object,\n    {isArray} = Array,\n    hasOwn = ({}.hasOwnProperty),\n    internalStateObjPropsToIgnore = [\n        'type', 'replaced', 'iterateIn', 'iterateUnsetNumeric'\n    ];\n\nfunction nestedPathsFirst (a, b) {\n    let as = a.keypath.match(/\\./g);\n    let bs = a.keypath.match(/\\./g);\n    if (as) {\n        as = as.length;\n    }\n    if (bs) {\n        bs = bs.length;\n    }\n    return as > bs\n        ? -1\n        : as < bs\n            ? 1\n            : a.keypath < b.keypath\n                ? -1\n                : a.keypath > b.keypath;\n}\n\n/**\n * An instance of this class can be used to call `stringify()` and `parse()`.\n * Typeson resolves cyclic references by default. Can also be extended to\n * support custom types using the register() method.\n *\n * @constructor\n * @param {{cyclic: boolean}} [options] - if cyclic (default true),\n *   cyclic references will be handled gracefully.\n */\nclass Typeson {\n    constructor (options) {\n        this.options = options;\n\n        // Replacers signature: replace (value). Returns falsy if not\n        //   replacing. Otherwise ['Date', value.getTime()]\n        this.plainObjectReplacers = [];\n        this.nonplainObjectReplacers = [];\n\n        // Revivers: [{type => reviver}, {plain: boolean}].\n        //   Sample: [{'Date': value => new Date(value)}, {plain: false}]\n        this.revivers = {};\n\n        /** Types registered via register() */\n        this.types = {};\n    }\n\n    /**\n     * Serialize given object to Typeson.\n     * Initial arguments work identical to those of `JSON.stringify`.\n     * The `replacer` argument has nothing to do with our replacers.\n     * @param {*} obj\n     * @param {function|string[]} replacer\n     * @param {number|string} space\n     * @param {object} opts\n     * @returns {string|Promise} Promise resolves to a string\n     */\n    stringify (obj, replacer, space, opts) {\n        opts = {...this.options, ...opts, stringification: true};\n        const encapsulated = this.encapsulate(obj, null, opts);\n        if (isArray(encapsulated)) {\n            return JSON.stringify(encapsulated[0], replacer, space);\n        }\n        return encapsulated.then((res) => {\n            return JSON.stringify(res, replacer, space);\n        });\n    }\n\n    /**\n     * Also sync but throws on non-sync result\n     * @param {*} obj\n     * @param {function|string[]} replacer\n     * @param {number|string} space\n     * @param {object} opts\n     * @returns {string}\n     */\n    stringifySync (obj, replacer, space, opts) {\n        return this.stringify(obj, replacer, space, {\n            throwOnBadSyncType: true, ...opts, sync: true\n        });\n    }\n\n    /**\n     *\n     * @param {*} obj\n     * @param {function|string[]} replacer\n     * @param {number|string} space\n     * @param {object} opts\n     * @returns {Promise} Resolves to string\n     */\n    stringifyAsync (obj, replacer, space, opts) {\n        return this.stringify(obj, replacer, space, {\n            throwOnBadSyncType: true, ...opts, sync: false\n        });\n    }\n\n    /**\n     * Parse Typeson back into an obejct.\n     * Initial arguments works identical to those of `JSON.parse()`.\n     * @param {string} text\n     * @param {function} reviver This JSON reviver has nothing to do with\n     *   our revivers.\n     * @param {object} opts\n     * @returns {external:JSON}\n     */\n    parse (text, reviver, opts) {\n        opts = {...this.options, ...opts, parse: true};\n        return this.revive(JSON.parse(text, reviver), opts);\n    }\n\n    /**\n    * Also sync but throws on non-sync result\n    * @param {string} text\n    * @param {function} reviver This JSON reviver has nothing to do with\n    *   our revivers.\n    * @param {object} opts\n    * @returns {external:JSON}\n    */\n    parseSync (text, reviver, opts) {\n        return this.parse(\n            text,\n            reviver,\n            {throwOnBadSyncType: true, ...opts, sync: true}\n        );\n    }\n    /**\n    * @param {string} text\n    * @param {function} reviver This JSON reviver has nothing to do with\n    *   our revivers.\n    * @param {object} opts\n    * @returns {Promise} Resolves to `external:JSON`\n    */\n    parseAsync (text, reviver, opts) {\n        return this.parse(\n            text,\n            reviver,\n            {throwOnBadSyncType: true, ...opts, sync: false}\n        );\n    }\n\n    /**\n     *\n     * @param {*} obj\n     * @param {object} stateObj\n     * @param {object} [opts={}]\n     * @returns {string[]|false}\n     */\n    specialTypeNames (obj, stateObj, opts = {}) {\n        opts.returnTypeNames = true;\n        return this.encapsulate(obj, stateObj, opts);\n    }\n\n    /**\n     *\n     * @param {*} obj\n     * @param {object} stateObj\n     * @param {object} [opts={}]\n     * @returns {Promise|Array|object|string|false}\n     */\n    rootTypeName (obj, stateObj, opts = {}) {\n        opts.iterateNone = true;\n        return this.encapsulate(obj, stateObj, opts);\n    }\n\n    /**\n     * Encapsulate a complex object into a plain Object by replacing\n     * registered types with plain objects representing the types data.\n     *\n     * This method is used internally by T`ypeson.stringify()`.\n     * @param {Object} obj - Object to encapsulate.\n     * @param {object} stateObj\n     * @param {object} opts\n     * @returns {Promise|Array|object|string|false}\n     */\n    encapsulate (obj, stateObj, opts) {\n        opts = {sync: true, ...this.options, ...opts};\n        const {sync} = opts;\n\n        const that = this,\n            types = {},\n            refObjs = [], // For checking cyclic references\n            refKeys = [], // For checking cyclic references\n            promisesDataRoot = [];\n\n        // Clone the object deeply while at the same time replacing any\n        //   special types or cyclic reference:\n        const cyclic = 'cyclic' in opts ? opts.cyclic : true;\n        const {encapsulateObserver} = opts;\n        const ret = _encapsulate(\n            '', obj, cyclic, stateObj || {},\n            promisesDataRoot\n        );\n\n        /**\n         *\n         * @param {*} ret\n         * @returns {Array|object|string|false}\n         */\n        function finish (ret) {\n            // Add `$types` to result only if we ever bumped into a\n            //  special type (or special case where object has own `$types`)\n            const typeNames = Object.values(types);\n            if (opts.iterateNone) {\n                if (typeNames.length) {\n                    return typeNames[0];\n                }\n                return Typeson.getJSONType(ret);\n            }\n            if (typeNames.length) {\n                if (opts.returnTypeNames) {\n                    return [...new Set(typeNames)];\n                }\n\n                // Special if array (or a primitive) was serialized\n                //   because JSON would ignore custom `$types` prop on it\n                if (!ret || !isPlainObject(ret) ||\n                    // Also need to handle if this is an object with its\n                    //   own `$types` property (to avoid ambiguity)\n                    hasOwn.call(ret, '$types')\n                ) {\n                    ret = {$: ret, $types: {$: types}};\n                } else {\n                    ret.$types = types;\n                }\n            // No special types\n            } else if (isObject(ret) && hasOwn.call(ret, '$types')) {\n                ret = {$: ret, $types: true};\n            }\n            if (opts.returnTypeNames) {\n                return false;\n            }\n            return ret;\n        }\n        /**\n         *\n         * @param {*} ret\n         * @param {array} promisesData\n         * @returns {Promise} Resolves to ...\n         */\n        async function checkPromises (ret, promisesData) {\n            const promResults = await Promise.all(\n                promisesData.map((pd) => { return pd[1].p; })\n            );\n            await Promise.all(\n                promResults.map(async function (promResult) {\n                    const newPromisesData = [];\n                    const [prData] = promisesData.splice(0, 1);\n                    const [\n                        keyPath, , cyclic, stateObj,\n                        parentObj, key, detectedType\n                    ] = prData;\n\n                    const encaps = _encapsulate(\n                        keyPath, promResult, cyclic, stateObj,\n                        newPromisesData, true, detectedType\n                    );\n                    const isTypesonPromise = hasConstructorOf(\n                        encaps,\n                        TypesonPromise\n                    );\n                    // Handle case where an embedded custom type itself\n                    //   returns a `Typeson.Promise`\n                    if (keyPath && isTypesonPromise) {\n                        const encaps2 = await encaps.p;\n                        parentObj[key] = encaps2;\n                        return checkPromises(ret, newPromisesData);\n                    }\n                    if (keyPath) {\n                        parentObj[key] = encaps;\n                    } else if (isTypesonPromise) {\n                        ret = encaps.p;\n                    } else {\n                        // If this is itself a `Typeson.Promise` (because the\n                        //   original value supplied was a `Promise` or\n                        //   because the supplied custom type value resolved\n                        //   to one), returning it below will be fine since\n                        //   a `Promise` is expected anyways given current\n                        //   config (and if not a `Promise`, it will be ready\n                        //   as the resolve value)\n                        ret = encaps;\n                    }\n                    return checkPromises(ret, newPromisesData);\n                })\n            );\n            return ret;\n        }\n\n        /**\n         *\n         * @param {object} stateObj\n         * @param {object} ownKeysObj\n         * @param {function} cb\n         * @returns {undefined}\n         */\n        function _adaptBuiltinStateObjectProperties (\n            stateObj, ownKeysObj, cb\n        ) {\n            Object.assign(stateObj, ownKeysObj);\n            const vals = internalStateObjPropsToIgnore.map((prop) => {\n                const tmp = stateObj[prop];\n                delete stateObj[prop];\n                return tmp;\n            });\n            cb();\n            internalStateObjPropsToIgnore.forEach((prop, i) => {\n                stateObj[prop] = vals[i];\n            });\n        }\n\n        /**\n         *\n         * @param {string} keypath\n         * @param {*} value\n         * @param {boolean} cyclic\n         * @param {object} stateObj\n         * @param {boolean} promisesData\n         * @param {boolean} resolvingTypesonPromise\n         * @param {string} detectedType\n         * @returns {*}\n         */\n        function _encapsulate (\n            keypath, value, cyclic, stateObj, promisesData,\n            resolvingTypesonPromise, detectedType\n        ) {\n            let ret;\n            let observerData = {};\n            const $typeof = typeof value;\n            const runObserver = encapsulateObserver\n                ? function (obj) {\n                    const type = detectedType || stateObj.type || (\n                        Typeson.getJSONType(value)\n                    );\n                    encapsulateObserver(Object.assign(obj || observerData, {\n                        keypath,\n                        value,\n                        cyclic,\n                        stateObj,\n                        promisesData,\n                        resolvingTypesonPromise,\n                        awaitingTypesonPromise: hasConstructorOf(\n                            value,\n                            TypesonPromise\n                        )\n                    }, type !== undefined ? {type} : {}));\n                }\n                : null;\n            if (['string', 'boolean', 'number', 'undefined'].includes(\n                $typeof\n            )) {\n                if (value === undefined || ($typeof === 'number' &&\n                    (isNaN(value) || value === -Infinity ||\n                        value === Infinity)\n                )) {\n                    ret = replace(\n                        keypath, value, stateObj, promisesData,\n                        false, resolvingTypesonPromise, runObserver\n                    );\n                    if (ret !== value) {\n                        observerData = {replaced: ret};\n                    }\n                } else {\n                    ret = value;\n                }\n                if (runObserver) {\n                    runObserver();\n                }\n                return ret;\n            }\n            if (value === null) {\n                if (runObserver) {\n                    runObserver();\n                }\n                return value;\n            }\n            if (cyclic && !stateObj.iterateIn &&\n                !stateObj.iterateUnsetNumeric\n            ) {\n                // Options set to detect cyclic references and be able\n                //   to rewrite them.\n                const refIndex = refObjs.indexOf(value);\n                if (refIndex < 0) {\n                    if (cyclic === true) {\n                        refObjs.push(value);\n                        refKeys.push(keypath);\n                    }\n                } else {\n                    types[keypath] = '#';\n                    if (runObserver) {\n                        runObserver({\n                            cyclicKeypath: refKeys[refIndex]\n                        });\n                    }\n                    return '#' + refKeys[refIndex];\n                }\n            }\n            const isPlainObj = isPlainObject(value);\n            const isArr = isArray(value);\n            const replaced = (\n                // Running replace will cause infinite loop as will test\n                //   positive again\n                ((isPlainObj || isArr) &&\n                    (!that.plainObjectReplacers.length ||\n                        stateObj.replaced)) ||\n                stateObj.iterateIn\n            )\n                // Optimization: if plain object and no plain-object\n                //   replacers, don't try finding a replacer\n                ? value\n                : replace(\n                    keypath, value, stateObj, promisesData,\n                    isPlainObj || isArr,\n                    null,\n                    runObserver\n                );\n            let clone;\n            if (replaced !== value) {\n                ret = replaced;\n                observerData = {replaced};\n            } else {\n                if ((isArr && stateObj.iterateIn !== 'object') ||\n                    stateObj.iterateIn === 'array'\n                ) {\n                    clone = new Array(value.length);\n                    observerData = {clone};\n                } else if (isPlainObj || stateObj.iterateIn === 'object') {\n                    clone = {};\n                    if (stateObj.addLength) {\n                        clone.length = value.length;\n                    }\n                    observerData = {clone};\n                } else if (keypath === '' &&\n                    hasConstructorOf(value, TypesonPromise)\n                ) {\n                    promisesData.push([\n                        keypath, value, cyclic, stateObj,\n                        undefined, undefined, stateObj.type\n                    ]);\n                    ret = value;\n                } else {\n                    ret = value; // Only clone vanilla objects and arrays\n                }\n            }\n            if (runObserver) {\n                runObserver();\n            }\n\n            if (opts.iterateNone) {\n                return clone || ret;\n            }\n\n            if (!clone) {\n                return ret;\n            }\n\n            // Iterate object or array\n            if (stateObj.iterateIn) {\n                for (const key in value) {\n                    const ownKeysObj = {ownKeys: hasOwn.call(value, key)};\n                    _adaptBuiltinStateObjectProperties(\n                        stateObj,\n                        ownKeysObj,\n                        () => {\n                            const kp = keypath + (keypath ? '.' : '') +\n                                escapeKeyPathComponent(key);\n                            const val = _encapsulate(\n                                kp, value[key], !!cyclic, stateObj,\n                                promisesData, resolvingTypesonPromise\n                            );\n                            if (hasConstructorOf(val, TypesonPromise)) {\n                                promisesData.push([\n                                    kp, val, !!cyclic, stateObj,\n                                    clone, key, stateObj.type\n                                ]);\n                            } else if (val !== undefined) {\n                                clone[key] = val;\n                            }\n                        }\n                    );\n                }\n                if (runObserver) {\n                    runObserver({endIterateIn: true, end: true});\n                }\n            } else {\n                // Note: Non-indexes on arrays won't survive stringify so\n                //  somewhat wasteful for arrays, but so too is iterating\n                //  all numeric indexes on sparse arrays when not wanted\n                //  or filtering own keys for positive integers\n                keys(value).forEach(function (key) {\n                    const kp = keypath + (keypath ? '.' : '') +\n                        escapeKeyPathComponent(key);\n                    const ownKeysObj = {ownKeys: true};\n                    _adaptBuiltinStateObjectProperties(\n                        stateObj,\n                        ownKeysObj,\n                        () => {\n                            const val = _encapsulate(\n                                kp, value[key], !!cyclic, stateObj,\n                                promisesData, resolvingTypesonPromise\n                            );\n                            if (hasConstructorOf(val, TypesonPromise)) {\n                                promisesData.push([\n                                    kp, val, !!cyclic, stateObj,\n                                    clone, key, stateObj.type\n                                ]);\n                            } else if (val !== undefined) {\n                                clone[key] = val;\n                            }\n                        }\n                    );\n                });\n                if (runObserver) {\n                    runObserver({endIterateOwn: true, end: true});\n                }\n            }\n            // Iterate array for non-own numeric properties (we can't\n            //   replace the prior loop though as it iterates non-integer\n            //   keys)\n            if (stateObj.iterateUnsetNumeric) {\n                const vl = value.length;\n                for (let i = 0; i < vl; i++) {\n                    if (!(i in value)) {\n                        // No need to escape numeric\n                        const kp = keypath + (keypath ? '.' : '') + i;\n\n                        const ownKeysObj = {ownKeys: false};\n                        _adaptBuiltinStateObjectProperties(\n                            stateObj,\n                            ownKeysObj,\n                            () => {\n                                const val = _encapsulate(\n                                    kp, undefined, !!cyclic, stateObj,\n                                    promisesData, resolvingTypesonPromise\n                                );\n                                if (hasConstructorOf(val, TypesonPromise)) {\n                                    promisesData.push([\n                                        kp, val, !!cyclic, stateObj,\n                                        clone, i, stateObj.type\n                                    ]);\n                                } else if (val !== undefined) {\n                                    clone[i] = val;\n                                }\n                            }\n                        );\n                    }\n                }\n                if (runObserver) {\n                    runObserver({endIterateUnsetNumeric: true, end: true});\n                }\n            }\n            return clone;\n        }\n\n        /**\n         *\n         * @param {string} keypath\n         * @param {*} value\n         * @param {object} stateObj\n         * @param {array} promisesData\n         * @param {boolean} plainObject\n         * @param {boolean} resolvingTypesonPromise\n         * @param {function} [runObserver]\n         * @returns {*}\n         */\n        function replace (\n            keypath, value, stateObj, promisesData, plainObject,\n            resolvingTypesonPromise, runObserver\n        ) {\n            // Encapsulate registered types\n            const replacers = plainObject\n                ? that.plainObjectReplacers\n                : that.nonplainObjectReplacers;\n            let i = replacers.length;\n            while (i--) {\n                const replacer = replacers[i];\n                if (replacer.test(value, stateObj)) {\n                    const {type} = replacer;\n                    if (that.revivers[type]) {\n                        // Record the type only if a corresponding reviver\n                        //   exists. This is to support specs where only\n                        //   replacement is done.\n                        // For example, ensuring deep cloning of the object,\n                        //   or replacing a type to its equivalent without\n                        //   the need to revive it.\n                        const existing = types[keypath];\n                        // type can comprise an array of types (see test\n                        //   `shouldSupportIntermediateTypes`)\n                        types[keypath] = existing\n                            ? [type].concat(existing)\n                            : type;\n                    }\n                    // Now, also traverse the result in case it contains its\n                    //   own types to replace\n                    Object.assign(stateObj, {type, replaced: true});\n                    if ((sync || !replacer.replaceAsync) &&\n                        !replacer.replace\n                    ) {\n                        if (runObserver) {\n                            runObserver({typeDetected: true});\n                        }\n                        return _encapsulate(\n                            keypath, value, cyclic && 'readonly', stateObj,\n                            promisesData, resolvingTypesonPromise, type\n                        );\n                    }\n                    if (runObserver) {\n                        runObserver({replacing: true});\n                    }\n\n                    const replaceMethod = sync || !replacer.replaceAsync\n                        ? 'replace'\n                        : 'replaceAsync';\n                    return _encapsulate(\n                        keypath, replacer[replaceMethod](value, stateObj),\n                        cyclic && 'readonly', stateObj, promisesData,\n                        resolvingTypesonPromise, type\n                    );\n                }\n            }\n            return value;\n        }\n\n        return promisesDataRoot.length\n            ? sync && opts.throwOnBadSyncType\n                ? (() => {\n                    throw new TypeError(\n                        'Sync method requested but async result obtained'\n                    );\n                })()\n                : Promise.resolve(\n                    checkPromises(ret, promisesDataRoot)\n                ).then(finish)\n            : !sync && opts.throwOnBadSyncType\n                ? (() => {\n                    throw new TypeError(\n                        'Async method requested but sync result obtained'\n                    );\n                })()\n                // If this is a synchronous request for stringification, yet\n                //   a promise is the result, we don't want to resolve leading\n                //   to an async result, so we return an array to avoid\n                //   ambiguity\n                : (opts.stringification && sync\n                    ? [finish(ret)]\n                    : (sync\n                        ? finish(ret)\n                        : Promise.resolve(finish(ret))\n                    ));\n    }\n\n    /**\n     * Also sync but throws on non-sync result\n     * @param {*} obj\n     * @param {object} stateObj\n     * @param {object} opts\n     * @returns {*}\n     */\n    encapsulateSync (obj, stateObj, opts) {\n        return this.encapsulate(obj, stateObj, {\n            throwOnBadSyncType: true, ...opts, sync: true\n        });\n    }\n\n    /**\n     * @param {*} obj\n     * @param {object} stateObj\n     * @param {object} opts\n     * @returns {*}\n     */\n    encapsulateAsync (obj, stateObj, opts) {\n        return this.encapsulate(obj, stateObj, {\n            throwOnBadSyncType: true, ...opts, sync: false\n        });\n    }\n\n    /**\n     * Revive an encapsulated object.\n     * This method is used internally by `Typeson.parse()`.\n     * @param {object} obj - Object to revive. If it has `$types` member, the\n     *   properties that are listed there will be replaced with its true type\n     *   instead of just plain objects.\n     * @param {object} opts\n     * @throws TypeError If mismatch between sync/async type and result\n     * @returns {Promise|*} If async, returns a Promise that resolves to `*`\n     */\n    revive (obj, opts) {\n        let types = obj && obj.$types;\n\n        // No type info added. Revival not needed.\n        if (!types) {\n            return obj;\n        }\n\n        // Object happened to have own `$types` property but with\n        //   no actual types, so we unescape and return that object\n        if (types === true) {\n            return obj.$;\n        }\n\n        opts = {sync: true, ...this.options, ...opts};\n        const {sync} = opts;\n        const keyPathResolutions = [];\n        const stateObj = {};\n\n        let ignore$Types = true;\n        // Special when root object is not a trivial Object, it will\n        //   be encapsulated in `$`. It will also be encapsulated in\n        //   `$` if it has its own `$` property to avoid ambiguity\n        if (types.$ && isPlainObject(types.$)) {\n            obj = obj.$;\n            types = types.$;\n            ignore$Types = false;\n        }\n\n        const that = this;\n        function revivePlainObjects () {\n            // const references = [];\n            // const reviveTypes = [];\n            const plainObjectTypes = [];\n            Object.entries(types).forEach(([\n                keypath, type\n            ]) => {\n                if (type === '#') {\n                    /*\n                    references.push({\n                        keypath,\n                        reference: getByKeyPath(obj, keypath)\n                    });\n                    */\n                    return;\n                }\n                [].concat(type).forEach(function (type) {\n                    const [, {plain}] = that.revivers[type];\n                    if (!plain) {\n                        // reviveTypes.push({keypath, type});\n                        return;\n                    }\n                    plainObjectTypes.push({keypath, type});\n                    delete types[keypath]; // Avoid repeating\n                });\n            });\n            if (!plainObjectTypes.length) {\n                return;\n            }\n            // Handle plain object revivers first so reference\n            //   setting can use revived type (e.g., array instead\n            //   of object); assumes revived has same structure\n            //   or will otherwise break subsequent references\n            return plainObjectTypes.sort(nestedPathsFirst).reduce(\n                function reducer (possibleTypesonPromise, {\n                    keypath, type\n                }) {\n                    if (hasConstructorOf(\n                        possibleTypesonPromise, TypesonPromise\n                    )) {\n                        // TypesonPromise here too\n                        return possibleTypesonPromise.then((v) => {\n                            return reducer(v, type);\n                        });\n                    }\n                    let val = getByKeyPath(obj, keypath);\n                    if (hasConstructorOf(val, TypesonPromise)) {\n                        return val.then((v) => { // TypesonPromise here too\n                            return reducer(v, type);\n                        });\n                    }\n                    const [reviver] = that.revivers[type];\n                    if (!reviver) {\n                        throw new Error('Unregistered type: ' + type);\n                    }\n                    val = reviver[\n                        sync && reviver.revive\n                            ? 'revive'\n                            : !sync && reviver.reviveAsync\n                                ? 'reviveAsync'\n                                : 'revive'\n                    ](val, stateObj);\n\n                    if (val === undefined) {\n                        return undefined;\n                    }\n                    if (hasConstructorOf(val, Undefined)) {\n                        val = undefined;\n                    }\n                    const newVal = setAtKeyPath(obj, keypath, val);\n                    if (newVal === val) {\n                        obj = val;\n                    }\n                    return undefined;\n                },\n                undefined // This argument must be explicit\n            );\n            // references.forEach(({keypath, reference}) => {});\n            // reviveTypes.sort(nestedPathsFirst).forEach(() => {});\n        }\n\n        /**\n         *\n         * @param {string} keypath\n         * @param {*} value\n         * @param {?(Array|object)} target\n         * @param {Array|object} [clone]\n         * @param {string} [key]\n         * @returns {*}\n         */\n        function _revive (keypath, value, target, clone, key) {\n            if (ignore$Types && keypath === '$types') {\n                return undefined;\n            }\n            const type = types[keypath];\n            if (isArray(value) || isPlainObject(value)) {\n                const clone = isArray(value) ? new Array(value.length) : {};\n                // Iterate object or array\n                keys(value).forEach((k) => {\n                    const val = _revive(\n                        keypath + (keypath ? '.' : '') +\n                            escapeKeyPathComponent(k), value[k],\n                        target || clone,\n                        clone,\n                        k\n                    );\n                    if (hasConstructorOf(val, Undefined)) {\n                        clone[k] = undefined;\n                    } else if (val !== undefined) {\n                        clone[k] = val;\n                    }\n                });\n                value = clone;\n                // Try to resolve cyclic reference as soon as available\n                while (keyPathResolutions.length) {\n                    const [[target, keyPath, clone, k]] = keyPathResolutions;\n                    const val = getByKeyPath(target, keyPath);\n                    if (hasConstructorOf(val, Undefined)) {\n                        clone[k] = undefined;\n                    } else if (val !== undefined) {\n                        clone[k] = val;\n                    } else {\n                        break;\n                    }\n                    keyPathResolutions.splice(0, 1);\n                }\n            }\n            if (!type) {\n                return value;\n            }\n            if (type === '#') {\n                const ret = getByKeyPath(target, value.slice(1));\n                if (ret === undefined) { // Cyclic reference not yet available\n                    keyPathResolutions.push([\n                        target, value.slice(1), clone, key\n                    ]);\n                }\n                return ret;\n            }\n            return [].concat(type).reduce(function reducer (val, type) {\n                if (hasConstructorOf(val, TypesonPromise)) {\n                    return val.then((v) => { // TypesonPromise here too\n                        return reducer(v, type);\n                    });\n                }\n                const [reviver] = that.revivers[type];\n                if (!reviver) {\n                    throw new Error('Unregistered type: ' + type);\n                }\n                return reviver[\n                    sync && reviver.revive\n                        ? 'revive'\n                        : !sync && reviver.reviveAsync\n                            ? 'reviveAsync'\n                            : 'revive'\n                ](val, stateObj);\n            }, value);\n        }\n\n        function checkUndefined (retrn) {\n            return hasConstructorOf(retrn, Undefined) ? undefined : retrn;\n        }\n\n        const possibleTypesonPromise = revivePlainObjects();\n        let ret;\n        if (hasConstructorOf(possibleTypesonPromise, TypesonPromise)) {\n            ret = possibleTypesonPromise.then(() => {\n                return _revive('', obj, null);\n            });\n        } else {\n            ret = _revive('', obj, null);\n        }\n\n        return isThenable(ret)\n            ? sync && opts.throwOnBadSyncType\n                ? (() => {\n                    throw new TypeError(\n                        'Sync method requested but async result obtained'\n                    );\n                })()\n                : hasConstructorOf(ret, TypesonPromise)\n                    ? ret.p.then(checkUndefined)\n                    : ret\n            : !sync && opts.throwOnBadSyncType\n                ? (() => {\n                    throw new TypeError(\n                        'Async method requested but sync result obtained'\n                    );\n                })()\n                : sync\n                    ? checkUndefined(ret)\n                    : Promise.resolve(checkUndefined(ret));\n    }\n\n    /**\n     * Also sync but throws on non-sync result\n     * @param {*} obj\n     * @param {object} opts\n     * @returns {*}\n     */\n    reviveSync (obj, opts) {\n        return this.revive(obj, {\n            throwOnBadSyncType: true, ...opts, sync: true\n        });\n    }\n\n    /**\n    * @param {*} obj\n    * @param {object} opts\n    * @returns {Promise} Resolves to `*`\n    */\n    reviveAsync (obj, opts) {\n        return this.revive(obj, {\n            throwOnBadSyncType: true, ...opts, sync: false\n        });\n    }\n\n    /**\n     * Register types.\n     * For examples on how to use this method, see\n     *   {@link https://github.com/dfahlander/typeson-registry/tree/master/types}\n     * @param {Array.<Object.<string,Function[]>>} typeSpecSets - Types and\n     *   their functions [test, encapsulate, revive];\n     * @param {object} opts\n     * @returns {Typeson}\n     */\n    register (typeSpecSets, opts) {\n        opts = opts || {};\n        [].concat(typeSpecSets).forEach(function R (typeSpec) {\n            // Allow arrays of arrays of arrays...\n            if (isArray(typeSpec)) {\n                return typeSpec.map(R, this);\n            }\n            typeSpec && keys(typeSpec).forEach(function (typeId) {\n                if (typeId === '#') {\n                    throw new TypeError(\n                        '# cannot be used as a type name as it is reserved ' +\n                        'for cyclic objects'\n                    );\n                } else if (Typeson.JSON_TYPES.includes(typeId)) {\n                    throw new TypeError(\n                        'Plain JSON object types are reserved as type names'\n                    );\n                }\n                let spec = typeSpec[typeId];\n                const replacers = spec.testPlainObjects\n                    ? this.plainObjectReplacers\n                    : this.nonplainObjectReplacers;\n                const existingReplacer = replacers.filter(function (r) {\n                    return r.type === typeId;\n                });\n                if (existingReplacer.length) {\n                    // Remove existing spec and replace with this one.\n                    replacers.splice(replacers.indexOf(existingReplacer[0]), 1);\n                    delete this.revivers[typeId];\n                    delete this.types[typeId];\n                }\n                if (!spec) {\n                    return;\n                }\n                if (typeof spec === 'function') {\n                    // Support registering just a class without replacer/reviver\n                    const Class = spec;\n                    spec = {\n                        test: (x) => x && x.constructor === Class,\n                        replace: (x) => Object.assign({}, x),\n                        revive: (x) => Object.assign(\n                            Object.create(Class.prototype), x\n                        )\n                    };\n                } else if (isArray(spec)) {\n                    const [test, replace, revive] = spec;\n                    spec = {test, replace, revive};\n                }\n                const replacerObj = {\n                    type: typeId,\n                    test: spec.test.bind(spec)\n                };\n                if (spec.replace) {\n                    replacerObj.replace = spec.replace.bind(spec);\n                }\n                if (spec.replaceAsync) {\n                    replacerObj.replaceAsync = spec.replaceAsync.bind(spec);\n                }\n                const start = typeof opts.fallback === 'number'\n                    ? opts.fallback\n                    : (opts.fallback ? 0 : Infinity);\n                if (spec.testPlainObjects) {\n                    this.plainObjectReplacers.splice(start, 0, replacerObj);\n                } else {\n                    this.nonplainObjectReplacers.splice(start, 0, replacerObj);\n                }\n                // Todo: We might consider a testAsync type\n                if (spec.revive || spec.reviveAsync) {\n                    const reviverObj = {};\n                    if (spec.revive) {\n                        reviverObj.revive = spec.revive.bind(spec);\n                    }\n                    if (spec.reviveAsync) {\n                        reviverObj.reviveAsync = spec.reviveAsync.bind(spec);\n                    }\n                    this.revivers[typeId] = [reviverObj, {\n                        plain: spec.testPlainObjects\n                    }];\n                }\n\n                // Record to be retrieved via public types property.\n                this.types[typeId] = spec;\n            }, this);\n        }, this);\n        return this;\n    }\n}\n\n/**\n * We keep this function minimized so if using two instances of this\n * library, where one is minimized and one is not, it will still work\n * with `hasConstructorOf`.\n * @constructor\n */\nclass Undefined{} // eslint-disable-line space-before-blocks\n\n// The following provide classes meant to avoid clashes with other values\n\n// To insist `undefined` should be added\nTypeson.Undefined = Undefined;\n// To support async encapsulation/stringification\nTypeson.Promise = TypesonPromise;\n\n// Some fundamental type-checking utilities\nTypeson.isThenable = isThenable;\nTypeson.toStringTag = toStringTag;\nTypeson.hasConstructorOf = hasConstructorOf;\nTypeson.isObject = isObject;\nTypeson.isPlainObject = isPlainObject;\nTypeson.isUserObject = isUserObject;\n\nTypeson.escapeKeyPathComponent = escapeKeyPathComponent;\nTypeson.unescapeKeyPathComponent = unescapeKeyPathComponent;\nTypeson.getByKeyPath = getByKeyPath;\nTypeson.getJSONType = getJSONType;\nTypeson.JSON_TYPES = [\n    'null', 'boolean', 'number', 'string', 'array', 'object'\n];\n\nexport default Typeson;\n","import Typeson from 'typeson';\nexport default {\n    error: {\n        test (x) { return Typeson.toStringTag(x) === 'Error'; },\n        replace ({name, message}) {\n            return {name, message};\n        },\n        revive ({name, message}) {\n            const e = new Error(message);\n            e.name = name;\n            return e;\n        }\n    }\n};\n// See also errors.js that may be registered after having registered this type.\n","/* eslint-env browser, node */\nimport Typeson from 'typeson';\nconst _global = typeof self === 'undefined' ? global : self;\n\nconst exportObj = {};\n// Comprises all built-in errors.\n[\n    'TypeError',\n    'RangeError',\n    'SyntaxError',\n    'ReferenceError',\n    'EvalError',\n    'URIError',\n    'InternalError' // non-standard\n].forEach((errName) => {\n    const constructor = _global[errName];\n    if (constructor) {\n        exportObj[errName.toLowerCase()] = {\n            test (x) { return Typeson.hasConstructorOf(x, constructor); },\n            replace (e) { return e.message; },\n            revive (message) { return new constructor(message); }\n        };\n    }\n});\n\nexport default exportObj;\n","/** When communicating via postMessage() (Worker.postMessage() or window.postMessage()),\n * the browser will use a similar algorithm as Typeson does to encapsulate and revive all\n * items in the structure (aka the structured clone algorithm). This algorithm supports all\n * built-in types as well as many DOM types. Therefore, only types that\n * are not included in the structured clone algorithm need to be registered, which is:\n * * Error\n * * Specific Errors like SyntaxError, TypeError, etc.\n * * Any custom type you want to send across window- or worker boundraries\n * This preset will only include the Error types and you can register your custom types\n * after having registered these.\n */\n\nimport error from '../types/error.js';\nimport errors from '../types/errors.js';\n\nexport default [\n    error,\n    errors\n];\n"],"names":["TypesonPromise","f","p","Promise","Symbol","prototype","toStringTag","then","onFulfilled","onRejected","typesonResolve","typesonReject","_this","res","r","reject","catch","this","resolve","v","map","meth","promArr","prom","toString","hasOwn","hasOwnProperty","getProto","Object","getPrototypeOf","fnToString","isThenable","catchCheck","isObject","val","call","slice","hasConstructorOf","a","b","_typeof","proto","Ctor","constructor","isPlainObject","escapeKeyPathComponent","keyPathComponent","replace","unescapeKeyPathComponent","getByKeyPath","obj","keyPath","period","indexOf","innerObj","substr","undefined","keys","isArray","Array","internalStateObjPropsToIgnore","nestedPathsFirst","as","keypath","match","bs","length","Typeson","options","plainObjectReplacers","nonplainObjectReplacers","revivers","types","replacer","space","opts","stringification","encapsulated","encapsulate","JSON","stringify","throwOnBadSyncType","sync","text","reviver","parse","revive","stateObj","returnTypeNames","iterateNone","that","refObjs","refKeys","promisesDataRoot","cyclic","encapsulateObserver","ret","_encapsulate","finish","typeNames","values","getJSONType","Set","$types","$","checkPromises","promisesData","all","pd","promResults","promResult","newPromisesData","splice","prData","parentObj","key","detectedType","encaps","isTypesonPromise","encaps2","_adaptBuiltinStateObjectProperties","ownKeysObj","cb","assign","vals","prop","tmp","forEach","i","value","resolvingTypesonPromise","observerData","$typeof","runObserver","type","awaitingTypesonPromise","includes","isNaN","Infinity","replaced","iterateIn","iterateUnsetNumeric","refIndex","cyclicKeypath","push","clone","isPlainObj","isArr","addLength","ownKeys","kp","endIterateIn","end","endIterateOwn","vl","endIterateUnsetNumeric","plainObject","replacers","test","existing","concat","replaceAsync","replacing","typeDetected","TypeError","keyPathResolutions","ignore$Types","_revive","target","k","Undefined","reduce","reducer","Error","reviveAsync","checkUndefined","retrn","possibleTypesonPromise","revivePlainObjects","plainObjectTypes","entries","plain","sort","setAtKeyPath","typeSpecSets","R","typeSpec","typeId","JSON_TYPES","spec","testPlainObjects","existingReplacer","filter","Class","x","create","replacerObj","bind","start","fallback","reviverObj","isUserObject","error","name","message","e","_global","self","global","exportObj","errName","toLowerCase","errors"],"mappings":"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"}