{"version":3,"file":"filelist.js","sources":["../../node_modules/typeson/dist/typeson-esm.js","../../utils/stringArrayBuffer.js","../../types/filelist.js","../../types/file.js"],"sourcesContent":["function _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  }\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\")) {\n    return;\n  }\n\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\n/**\n * We keep this function minimized so if using two instances of this\n *   library, where one is minimized and one is not, it will still work\n *   with `hasConstructorOf`.\n * With ES6 classes, we may be able to simply use `class TypesonPromise\n *   extends Promise` and add a string tag for detection.\n * @param {function} f\n */\n// eslint-disable-next-line max-len\n// eslint-disable-next-line block-spacing, space-before-function-paren, space-before-blocks, space-infix-ops, semi, promise/avoid-new\nvar TypesonPromise = function TypesonPromise(f) {\n  _classCallCheck(this, TypesonPromise);\n\n  this.p = new Promise(f);\n}; // eslint-disable-next-line max-len\n// class TypesonPromise extends Promise {get[Symbol.toStringTag](){return 'TypesonPromise'};} // eslint-disable-line keyword-spacing, space-before-function-paren, space-before-blocks, block-spacing, semi\n\n\nTypesonPromise.__typeson__type__ = 'TypesonPromise'; // Note: core-js-bundle provides a `Symbol` polyfill\n\n/* istanbul ignore else */\n\nif (typeof Symbol !== 'undefined') {\n  // Ensure `isUserObject` will return `false` for `TypesonPromise`\n  TypesonPromise.prototype[Symbol.toStringTag] = 'TypesonPromise';\n}\n/**\n *\n * @param {function} [onFulfilled]\n * @param {function} [onRejected]\n * @returns {TypesonPromise}\n */\n\n\nTypesonPromise.prototype.then = function (onFulfilled, onRejected) {\n  var _this = this;\n\n  return new TypesonPromise(function (typesonResolve, typesonReject) {\n    // eslint-disable-next-line promise/catch-or-return\n    _this.p.then(function (res) {\n      // eslint-disable-next-line promise/always-return\n      typesonResolve(onFulfilled ? onFulfilled(res) : res);\n    })[\"catch\"](function (res) {\n      return onRejected ? onRejected(res) : Promise.reject(res);\n    }).then(typesonResolve, typesonReject);\n  });\n};\n/**\n *\n * @param {function} onRejected\n * @returns {TypesonPromise}\n */\n\n\nTypesonPromise.prototype[\"catch\"] = function (onRejected) {\n  return this.then(null, onRejected);\n};\n/**\n *\n * @param {Any} v\n * @returns {TypesonPromise}\n */\n\n\nTypesonPromise.resolve = function (v) {\n  return new TypesonPromise(function (typesonResolve) {\n    typesonResolve(v);\n  });\n};\n/**\n *\n * @param {Any} v\n * @returns {TypesonPromise}\n */\n\n\nTypesonPromise.reject = function (v) {\n  return new TypesonPromise(function (typesonResolve, typesonReject) {\n    typesonReject(v);\n  });\n};\n\n['all', 'race'].forEach(function (meth) {\n  /**\n   *\n   * @param {Promise[]} promArr\n   * @returns {TypesonPromise}\n   */\n  TypesonPromise[meth] = function (promArr) {\n    return new TypesonPromise(function (typesonResolve, typesonReject) {\n      // eslint-disable-next-line promise/catch-or-return\n      Promise[meth](promArr.map(function (prom) {\n        return prom && prom.constructor && prom.constructor.__typeson__type__ === 'TypesonPromise' ? prom.p : prom;\n      })).then(typesonResolve, typesonReject);\n    });\n  };\n});\n\nvar _ref = {},\n    toStr = _ref.toString,\n    hasOwn = {}.hasOwnProperty,\n    getProto = Object.getPrototypeOf,\n    fnToString = hasOwn.toString;\n/**\n * Second argument not in use internally, but provided for utility.\n * @param {Any} v\n * @param {boolean} catchCheck\n * @returns {boolean}\n */\n\nfunction isThenable(v, catchCheck) {\n  return isObject(v) && typeof v.then === 'function' && (!catchCheck || typeof v[\"catch\"] === 'function');\n}\n/**\n *\n * @param {Any} val\n * @returns {string}\n */\n\n\nfunction toStringTag(val) {\n  return toStr.call(val).slice(8, -1);\n}\n/**\n * This function is dependent on both constructors\n *   being identical so any minimization is expected of both.\n * @param {Any} a\n * @param {function} b\n * @returns {boolean}\n */\n\n\nfunction hasConstructorOf(a, b) {\n  if (!a || _typeof(a) !== 'object') {\n    return false;\n  }\n\n  var proto = getProto(a);\n\n  if (!proto) {\n    return b === null;\n  }\n\n  var Ctor = hasOwn.call(proto, 'constructor') && proto.constructor;\n\n  if (typeof Ctor !== 'function') {\n    return b === null;\n  }\n\n  if (b === Ctor) {\n    return true;\n  }\n\n  if (b !== null && fnToString.call(Ctor) === fnToString.call(b)) {\n    return true;\n  }\n\n  if (typeof b === 'function' && typeof Ctor.__typeson__type__ === 'string' && Ctor.__typeson__type__ === b.__typeson__type__) {\n    return true;\n  }\n\n  return false;\n}\n/**\n *\n * @param {Any} val\n * @returns {boolean}\n */\n\n\nfunction isPlainObject(val) {\n  // Mirrors jQuery's\n  if (!val || toStringTag(val) !== 'Object') {\n    return false;\n  }\n\n  var proto = getProto(val);\n\n  if (!proto) {\n    // `Object.create(null)`\n    return true;\n  }\n\n  return hasConstructorOf(val, Object);\n}\n/**\n *\n * @param {Any} val\n * @returns {boolean}\n */\n\n\nfunction isUserObject(val) {\n  if (!val || toStringTag(val) !== 'Object') {\n    return false;\n  }\n\n  var proto = getProto(val);\n\n  if (!proto) {\n    // `Object.create(null)`\n    return true;\n  }\n\n  return hasConstructorOf(val, Object) || isUserObject(proto);\n}\n/**\n *\n * @param {Any} v\n * @returns {boolean}\n */\n\n\nfunction isObject(v) {\n  return v && _typeof(v) === 'object';\n}\n/**\n *\n * @param {string} keyPathComponent\n * @returns {string}\n */\n\n\nfunction escapeKeyPathComponent(keyPathComponent) {\n  return keyPathComponent.replace(/~/g, '~0').replace(/\\./g, '~1');\n}\n/**\n *\n * @param {string} keyPathComponent\n * @returns {string}\n */\n\n\nfunction unescapeKeyPathComponent(keyPathComponent) {\n  return keyPathComponent.replace(/~1/g, '.').replace(/~0/g, '~');\n}\n/**\n * @param {PlainObject|GenericArray} obj\n * @param {string} keyPath\n * @returns {Any}\n */\n\n\nfunction getByKeyPath(obj, keyPath) {\n  if (keyPath === '') {\n    return obj;\n  }\n\n  var period = keyPath.indexOf('.');\n\n  if (period > -1) {\n    var innerObj = obj[unescapeKeyPathComponent(keyPath.slice(0, period))];\n    return innerObj === undefined ? undefined : getByKeyPath(innerObj, keyPath.slice(period + 1));\n  }\n\n  return obj[unescapeKeyPathComponent(keyPath)];\n}\n/**\n *\n * @param {PlainObject} obj\n * @param {string} keyPath\n * @param {Any} value\n * @returns {Any}\n */\n\n\nfunction setAtKeyPath(obj, keyPath, value) {\n  if (keyPath === '') {\n    return value;\n  }\n\n  var period = keyPath.indexOf('.');\n\n  if (period > -1) {\n    var innerObj = obj[unescapeKeyPathComponent(keyPath.slice(0, period))];\n    return setAtKeyPath(innerObj, keyPath.slice(period + 1), value);\n  }\n\n  obj[unescapeKeyPathComponent(keyPath)] = value;\n  return obj;\n}\n/**\n *\n * @param {external:JSON} value\n * @returns {\"null\"|\"array\"|\"undefined\"|\"boolean\"|\"number\"|\"string\"|\n *  \"object\"|\"symbol\"}\n */\n\n\nfunction getJSONType(value) {\n  return value === null ? 'null' : Array.isArray(value) ? 'array' : _typeof(value);\n}\n\nvar keys = Object.keys,\n    isArray = Array.isArray,\n    hasOwn$1 = {}.hasOwnProperty,\n    internalStateObjPropsToIgnore = ['type', 'replaced', 'iterateIn', 'iterateUnsetNumeric'];\n/**\n * Handle plain object revivers first so reference setting can use\n * revived type (e.g., array instead of object); assumes revived\n * has same structure or will otherwise break subsequent references.\n * @param {PlainObjectType} a\n * @param {PlainObjectType} b\n * @returns {1|-1|boolean}\n */\n\nfunction nestedPathsFirst(a, b) {\n  if (a.keypath === '') {\n    return -1;\n  }\n\n  var as = a.keypath.match(/\\./g) || 0;\n  var bs = b.keypath.match(/\\./g) || 0;\n\n  if (as) {\n    as = as.length;\n  }\n\n  if (bs) {\n    bs = bs.length;\n  }\n\n  return as > bs ? -1 : as < bs ? 1 : a.keypath < b.keypath ? -1 : a.keypath > b.keypath;\n}\n/**\n * An instance of this class can be used to call `stringify()` and `parse()`.\n * Typeson resolves cyclic references by default. Can also be extended to\n * support custom types using the register() method.\n *\n * @class\n * @param {{cyclic: boolean}} [options] - if cyclic (default true),\n *   cyclic references will be handled gracefully.\n */\n\n\nvar Typeson =\n/*#__PURE__*/\nfunction () {\n  function Typeson(options) {\n    _classCallCheck(this, Typeson);\n\n    this.options = options; // Replacers signature: replace (value). Returns falsy if not\n    //   replacing. Otherwise ['Date', value.getTime()]\n\n    this.plainObjectReplacers = [];\n    this.nonplainObjectReplacers = []; // Revivers: [{type => reviver}, {plain: boolean}].\n    //   Sample: [{'Date': value => new Date(value)}, {plain: false}]\n\n    this.revivers = {};\n    /** Types registered via `register()`. */\n\n    this.types = {};\n  }\n  /**\n  * @typedef {null|boolean|number|string|GenericArray|PlainObject} JSON\n  */\n\n  /**\n  * @callback JSONReplacer\n  * @param {\"\"|string} key\n  * @param {JSON} value\n  * @returns {number|string|boolean|null|PlainObject|undefined}\n  * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#The%20replacer%20parameter\n  */\n\n  /**\n   * Serialize given object to Typeson.\n   * Initial arguments work identical to those of `JSON.stringify`.\n   * The `replacer` argument has nothing to do with our replacers.\n   * @param {Any} obj\n   * @param {JSONReplacer|string[]} replacer\n   * @param {number|string} space\n   * @param {object} opts\n   * @returns {string|Promise} Promise resolves to a string\n   */\n\n\n  _createClass(Typeson, [{\n    key: \"stringify\",\n    value: function stringify(obj, replacer, space, opts) {\n      opts = _objectSpread2({}, this.options, {}, opts, {\n        stringification: true\n      });\n      var encapsulated = this.encapsulate(obj, null, opts);\n\n      if (isArray(encapsulated)) {\n        return JSON.stringify(encapsulated[0], replacer, space);\n      }\n\n      return encapsulated.then(function (res) {\n        return JSON.stringify(res, replacer, space);\n      });\n    }\n    /**\n     * Also sync but throws on non-sync result.\n     * @param {Any} obj\n     * @param {JSONReplacer|string[]} replacer\n     * @param {number|string} space\n     * @param {object} opts\n     * @returns {string}\n     */\n\n  }, {\n    key: \"stringifySync\",\n    value: function stringifySync(obj, replacer, space, opts) {\n      return this.stringify(obj, replacer, space, _objectSpread2({\n        throwOnBadSyncType: true\n      }, opts, {\n        sync: true\n      }));\n    }\n    /**\n     *\n     * @param {Any} obj\n     * @param {JSONReplacer|string[]} replacer\n     * @param {number|string} space\n     * @param {object} opts\n     * @returns {Promise<string>}\n     */\n\n  }, {\n    key: \"stringifyAsync\",\n    value: function stringifyAsync(obj, replacer, space, opts) {\n      return this.stringify(obj, replacer, space, _objectSpread2({\n        throwOnBadSyncType: true\n      }, opts, {\n        sync: false\n      }));\n    }\n    /**\n     * Parse Typeson back into an obejct.\n     * Initial arguments works identical to those of `JSON.parse()`.\n     * @param {string} text\n     * @param {function} reviver This JSON reviver has nothing to do with\n     *   our revivers.\n     * @param {object} opts\n     * @returns {external:JSON}\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(text, reviver, opts) {\n      opts = _objectSpread2({}, this.options, {}, opts, {\n        parse: true\n      });\n      return this.revive(JSON.parse(text, reviver), opts);\n    }\n    /**\n    * Also sync but throws on non-sync result.\n    * @param {string} text\n    * @param {function} reviver This JSON reviver has nothing to do with\n    *   our revivers.\n    * @param {object} opts\n    * @returns {external:JSON}\n    */\n\n  }, {\n    key: \"parseSync\",\n    value: function parseSync(text, reviver, opts) {\n      return this.parse(text, reviver, _objectSpread2({\n        throwOnBadSyncType: true\n      }, opts, {\n        sync: true\n      }));\n    }\n    /**\n    * @param {string} text\n    * @param {function} reviver This JSON reviver has nothing to do with\n    *   our revivers.\n    * @param {object} opts\n    * @returns {Promise} Resolves to `external:JSON`\n    */\n\n  }, {\n    key: \"parseAsync\",\n    value: function parseAsync(text, reviver, opts) {\n      return this.parse(text, reviver, _objectSpread2({\n        throwOnBadSyncType: true\n      }, opts, {\n        sync: false\n      }));\n    }\n    /**\n     *\n     * @param {Any} obj\n     * @param {object} stateObj\n     * @param {object} [opts={}]\n     * @returns {string[]|false}\n     */\n\n  }, {\n    key: \"specialTypeNames\",\n    value: function specialTypeNames(obj, stateObj) {\n      var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      opts.returnTypeNames = true;\n      return this.encapsulate(obj, stateObj, opts);\n    }\n    /**\n     *\n     * @param {Any} obj\n     * @param {PlainObject} stateObj\n     * @param {PlainObject} [opts={}]\n     * @returns {Promise|GenericArray|PlainObject|string|false}\n     */\n\n  }, {\n    key: \"rootTypeName\",\n    value: function rootTypeName(obj, stateObj) {\n      var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      opts.iterateNone = true;\n      return this.encapsulate(obj, stateObj, opts);\n    }\n    /**\n     * Encapsulate a complex object into a plain Object by replacing\n     * registered types with plain objects representing the types data.\n     *\n     * This method is used internally by `Typeson.stringify()`.\n     * @param {Any} obj - Object to encapsulate.\n     * @param {PlainObject} stateObj\n     * @param {PlainObject} opts\n     * @returns {Promise|GenericArray|PlainObject|string|false}\n     */\n\n  }, {\n    key: \"encapsulate\",\n    value: function encapsulate(obj, stateObj, opts) {\n      opts = _objectSpread2({\n        sync: true\n      }, this.options, {}, opts);\n      var _opts = opts,\n          sync = _opts.sync;\n      var that = this,\n          types = {},\n          refObjs = [],\n          // For checking cyclic references\n      refKeys = [],\n          // For checking cyclic references\n      promisesDataRoot = []; // Clone the object deeply while at the same time replacing any\n      //   special types or cyclic reference:\n\n      var cyclic = 'cyclic' in opts ? opts.cyclic : true;\n      var _opts2 = opts,\n          encapsulateObserver = _opts2.encapsulateObserver;\n\n      var ret = _encapsulate('', obj, cyclic, stateObj || {}, promisesDataRoot);\n      /**\n       *\n       * @param {Any} ret\n       * @returns {GenericArray|PlainObject|string|false}\n       */\n\n\n      function finish(ret) {\n        // Add `$types` to result only if we ever bumped into a\n        //  special type (or special case where object has own `$types`)\n        var typeNames = Object.values(types);\n\n        if (opts.iterateNone) {\n          if (typeNames.length) {\n            return typeNames[0];\n          }\n\n          return Typeson.getJSONType(ret);\n        }\n\n        if (typeNames.length) {\n          if (opts.returnTypeNames) {\n            return _toConsumableArray(new Set(typeNames));\n          } // Special if array (or a primitive) was serialized\n          //   because JSON would ignore custom `$types` prop on it\n\n\n          if (!ret || !isPlainObject(ret) || // Also need to handle if this is an object with its\n          //   own `$types` property (to avoid ambiguity)\n          hasOwn$1.call(ret, '$types')) {\n            ret = {\n              $: ret,\n              $types: {\n                $: types\n              }\n            };\n          } else {\n            ret.$types = types;\n          } // No special types\n\n        } else if (isObject(ret) && hasOwn$1.call(ret, '$types')) {\n          ret = {\n            $: ret,\n            $types: true\n          };\n        }\n\n        if (opts.returnTypeNames) {\n          return false;\n        }\n\n        return ret;\n      }\n      /**\n       *\n       * @param {Any} ret\n       * @param {GenericArray} promisesData\n       * @returns {Promise<Any>}\n       */\n\n\n      function checkPromises(_x, _x2) {\n        return _checkPromises.apply(this, arguments);\n      }\n      /**\n       *\n       * @param {object} stateObj\n       * @param {object} ownKeysObj\n       * @param {function} cb\n       * @returns {undefined}\n       */\n\n\n      function _checkPromises() {\n        _checkPromises = _asyncToGenerator(\n        /*#__PURE__*/\n        regeneratorRuntime.mark(function _callee2(ret, promisesData) {\n          var promResults;\n          return regeneratorRuntime.wrap(function _callee2$(_context2) {\n            while (1) {\n              switch (_context2.prev = _context2.next) {\n                case 0:\n                  _context2.next = 2;\n                  return Promise.all(promisesData.map(function (pd) {\n                    return pd[1].p;\n                  }));\n\n                case 2:\n                  promResults = _context2.sent;\n                  _context2.next = 5;\n                  return Promise.all(promResults.map(\n                  /*#__PURE__*/\n                  function () {\n                    var _ref = _asyncToGenerator(\n                    /*#__PURE__*/\n                    regeneratorRuntime.mark(function _callee(promResult) {\n                      var newPromisesData, _promisesData$splice, _promisesData$splice2, prData, _prData, keyPath, cyclic, stateObj, parentObj, key, detectedType, encaps, isTypesonPromise, encaps2;\n\n                      return regeneratorRuntime.wrap(function _callee$(_context) {\n                        while (1) {\n                          switch (_context.prev = _context.next) {\n                            case 0:\n                              newPromisesData = [];\n                              _promisesData$splice = promisesData.splice(0, 1), _promisesData$splice2 = _slicedToArray(_promisesData$splice, 1), prData = _promisesData$splice2[0];\n                              _prData = _slicedToArray(prData, 7), keyPath = _prData[0], cyclic = _prData[2], stateObj = _prData[3], parentObj = _prData[4], key = _prData[5], detectedType = _prData[6];\n                              encaps = _encapsulate(keyPath, promResult, cyclic, stateObj, newPromisesData, true, detectedType);\n                              isTypesonPromise = hasConstructorOf(encaps, TypesonPromise); // Handle case where an embedded custom type itself\n                              //   returns a `Typeson.Promise`\n\n                              if (!(keyPath && isTypesonPromise)) {\n                                _context.next = 11;\n                                break;\n                              }\n\n                              _context.next = 8;\n                              return encaps.p;\n\n                            case 8:\n                              encaps2 = _context.sent;\n                              parentObj[key] = encaps2;\n                              return _context.abrupt(\"return\", checkPromises(ret, newPromisesData));\n\n                            case 11:\n                              if (keyPath) {\n                                parentObj[key] = encaps;\n                              } else if (isTypesonPromise) {\n                                ret = encaps.p;\n                              } else {\n                                // If this is itself a `Typeson.Promise` (because the\n                                //   original value supplied was a `Promise` or\n                                //   because the supplied custom type value resolved\n                                //   to one), returning it below will be fine since\n                                //   a `Promise` is expected anyways given current\n                                //   config (and if not a `Promise`, it will be ready\n                                //   as the resolve value)\n                                ret = encaps;\n                              }\n\n                              return _context.abrupt(\"return\", checkPromises(ret, newPromisesData));\n\n                            case 13:\n                            case \"end\":\n                              return _context.stop();\n                          }\n                        }\n                      }, _callee);\n                    }));\n\n                    return function (_x3) {\n                      return _ref.apply(this, arguments);\n                    };\n                  }()));\n\n                case 5:\n                  return _context2.abrupt(\"return\", ret);\n\n                case 6:\n                case \"end\":\n                  return _context2.stop();\n              }\n            }\n          }, _callee2);\n        }));\n        return _checkPromises.apply(this, arguments);\n      }\n\n      function _adaptBuiltinStateObjectProperties(stateObj, ownKeysObj, cb) {\n        Object.assign(stateObj, ownKeysObj);\n        var vals = internalStateObjPropsToIgnore.map(function (prop) {\n          var tmp = stateObj[prop];\n          delete stateObj[prop];\n          return tmp;\n        }); // eslint-disable-next-line callback-return\n\n        cb();\n        internalStateObjPropsToIgnore.forEach(function (prop, i) {\n          stateObj[prop] = vals[i];\n        });\n      }\n      /**\n       *\n       * @param {string} keypath\n       * @param {Any} value\n       * @param {boolean} cyclic\n       * @param {PlainObject} stateObj\n       * @param {boolean} promisesData\n       * @param {boolean} resolvingTypesonPromise\n       * @param {string} detectedType\n       * @returns {Any}\n       */\n\n\n      function _encapsulate(keypath, value, cyclic, stateObj, promisesData, resolvingTypesonPromise, detectedType) {\n        var ret;\n        var observerData = {};\n\n        var $typeof = _typeof(value);\n\n        var runObserver = encapsulateObserver ? function (obj) {\n          var type = detectedType || stateObj.type || Typeson.getJSONType(value);\n          encapsulateObserver(Object.assign(obj || observerData, {\n            keypath: keypath,\n            value: value,\n            cyclic: cyclic,\n            stateObj: stateObj,\n            promisesData: promisesData,\n            resolvingTypesonPromise: resolvingTypesonPromise,\n            awaitingTypesonPromise: hasConstructorOf(value, TypesonPromise)\n          }, {\n            type: type\n          }));\n        } : null;\n\n        if (['string', 'boolean', 'number', 'undefined'].includes($typeof)) {\n          if (value === undefined || $typeof === 'number' && (isNaN(value) || value === -Infinity || value === Infinity)) {\n            if (stateObj.replaced) {\n              ret = value;\n            } else {\n              ret = replace(keypath, value, stateObj, promisesData, false, resolvingTypesonPromise, runObserver);\n            }\n\n            if (ret !== value) {\n              observerData = {\n                replaced: ret\n              };\n            }\n          } else {\n            ret = value;\n          }\n\n          if (runObserver) {\n            runObserver();\n          }\n\n          return ret;\n        }\n\n        if (value === null) {\n          if (runObserver) {\n            runObserver();\n          }\n\n          return value;\n        }\n\n        if (cyclic && !stateObj.iterateIn && !stateObj.iterateUnsetNumeric && value && _typeof(value) === 'object') {\n          // Options set to detect cyclic references and be able\n          //   to rewrite them.\n          var refIndex = refObjs.indexOf(value);\n\n          if (refIndex < 0) {\n            if (cyclic === true) {\n              refObjs.push(value);\n              refKeys.push(keypath);\n            }\n          } else {\n            types[keypath] = '#';\n\n            if (runObserver) {\n              runObserver({\n                cyclicKeypath: refKeys[refIndex]\n              });\n            }\n\n            return '#' + refKeys[refIndex];\n          }\n        }\n\n        var isPlainObj = isPlainObject(value);\n        var isArr = isArray(value);\n        var replaced = // Running replace will cause infinite loop as will test\n        //   positive again\n        (isPlainObj || isArr) && (!that.plainObjectReplacers.length || stateObj.replaced) || stateObj.iterateIn ? // Optimization: if plain object and no plain-object\n        //   replacers, don't try finding a replacer\n        value : replace(keypath, value, stateObj, promisesData, isPlainObj || isArr, null, runObserver);\n        var clone;\n\n        if (replaced !== value) {\n          ret = replaced;\n          observerData = {\n            replaced: replaced\n          };\n        } else {\n          // eslint-disable-next-line no-lonely-if\n          if (keypath === '' && hasConstructorOf(value, TypesonPromise)) {\n            promisesData.push([keypath, value, cyclic, stateObj, undefined, undefined, stateObj.type]);\n            ret = value;\n          } else if (isArr && stateObj.iterateIn !== 'object' || stateObj.iterateIn === 'array') {\n            clone = new Array(value.length);\n            observerData = {\n              clone: clone\n            };\n          } else if (!['function', 'symbol'].includes(_typeof(value)) && !('toJSON' in value) && !hasConstructorOf(value, TypesonPromise) && !hasConstructorOf(value, Promise) && !hasConstructorOf(value, ArrayBuffer) || isPlainObj || stateObj.iterateIn === 'object') {\n            clone = {};\n\n            if (stateObj.addLength) {\n              clone.length = value.length;\n            }\n\n            observerData = {\n              clone: clone\n            };\n          } else {\n            ret = value; // Only clone vanilla objects and arrays\n          }\n        }\n\n        if (runObserver) {\n          runObserver();\n        }\n\n        if (opts.iterateNone) {\n          return clone || ret;\n        }\n\n        if (!clone) {\n          return ret;\n        } // Iterate object or array\n\n\n        if (stateObj.iterateIn) {\n          var _loop = function _loop(key) {\n            var ownKeysObj = {\n              ownKeys: hasOwn$1.call(value, key)\n            };\n\n            _adaptBuiltinStateObjectProperties(stateObj, ownKeysObj, function () {\n              var kp = keypath + (keypath ? '.' : '') + escapeKeyPathComponent(key);\n\n              var val = _encapsulate(kp, value[key], Boolean(cyclic), stateObj, promisesData, resolvingTypesonPromise);\n\n              if (hasConstructorOf(val, TypesonPromise)) {\n                promisesData.push([kp, val, Boolean(cyclic), stateObj, clone, key, stateObj.type]);\n              } else if (val !== undefined) {\n                clone[key] = val;\n              }\n            });\n          };\n\n          // eslint-disable-next-line guard-for-in\n          for (var key in value) {\n            _loop(key);\n          }\n\n          if (runObserver) {\n            runObserver({\n              endIterateIn: true,\n              end: true\n            });\n          }\n        } else {\n          // Note: Non-indexes on arrays won't survive stringify so\n          //  somewhat wasteful for arrays, but so too is iterating\n          //  all numeric indexes on sparse arrays when not wanted\n          //  or filtering own keys for positive integers\n          keys(value).forEach(function (key) {\n            var kp = keypath + (keypath ? '.' : '') + escapeKeyPathComponent(key);\n            var ownKeysObj = {\n              ownKeys: true\n            };\n\n            _adaptBuiltinStateObjectProperties(stateObj, ownKeysObj, function () {\n              var val = _encapsulate(kp, value[key], Boolean(cyclic), stateObj, promisesData, resolvingTypesonPromise);\n\n              if (hasConstructorOf(val, TypesonPromise)) {\n                promisesData.push([kp, val, Boolean(cyclic), stateObj, clone, key, stateObj.type]);\n              } else if (val !== undefined) {\n                clone[key] = val;\n              }\n            });\n          });\n\n          if (runObserver) {\n            runObserver({\n              endIterateOwn: true,\n              end: true\n            });\n          }\n        } // Iterate array for non-own numeric properties (we can't\n        //   replace the prior loop though as it iterates non-integer\n        //   keys)\n\n\n        if (stateObj.iterateUnsetNumeric) {\n          var vl = value.length;\n\n          var _loop2 = function _loop2(i) {\n            if (!(i in value)) {\n              // No need to escape numeric\n              var kp = keypath + (keypath ? '.' : '') + i;\n              var ownKeysObj = {\n                ownKeys: false\n              };\n\n              _adaptBuiltinStateObjectProperties(stateObj, ownKeysObj, function () {\n                var val = _encapsulate(kp, undefined, Boolean(cyclic), stateObj, promisesData, resolvingTypesonPromise);\n\n                if (hasConstructorOf(val, TypesonPromise)) {\n                  promisesData.push([kp, val, Boolean(cyclic), stateObj, clone, i, stateObj.type]);\n                } else if (val !== undefined) {\n                  clone[i] = val;\n                }\n              });\n            }\n          };\n\n          for (var i = 0; i < vl; i++) {\n            _loop2(i);\n          }\n\n          if (runObserver) {\n            runObserver({\n              endIterateUnsetNumeric: true,\n              end: true\n            });\n          }\n        }\n\n        return clone;\n      }\n      /**\n       *\n       * @param {string} keypath\n       * @param {Any} value\n       * @param {PlainObject} stateObj\n       * @param {GenericArray} promisesData\n       * @param {boolean} plainObject\n       * @param {boolean} resolvingTypesonPromise\n       * @param {function} [runObserver]\n       * @returns {*}\n       */\n\n\n      function replace(keypath, value, stateObj, promisesData, plainObject, resolvingTypesonPromise, runObserver) {\n        // Encapsulate registered types\n        var replacers = plainObject ? that.plainObjectReplacers : that.nonplainObjectReplacers;\n        var i = replacers.length;\n\n        while (i--) {\n          var replacer = replacers[i];\n\n          if (replacer.test(value, stateObj)) {\n            var type = replacer.type;\n\n            if (that.revivers[type]) {\n              // Record the type only if a corresponding reviver\n              //   exists. This is to support specs where only\n              //   replacement is done.\n              // For example, ensuring deep cloning of the object,\n              //   or replacing a type to its equivalent without\n              //   the need to revive it.\n              var existing = types[keypath]; // type can comprise an array of types (see test\n              //   \"should support intermediate types\")\n\n              types[keypath] = existing ? [type].concat(existing) : type;\n            }\n\n            Object.assign(stateObj, {\n              type: type,\n              replaced: true\n            });\n\n            if ((sync || !replacer.replaceAsync) && !replacer.replace) {\n              if (runObserver) {\n                runObserver({\n                  typeDetected: true\n                });\n              }\n\n              return _encapsulate(keypath, value, cyclic && 'readonly', stateObj, promisesData, resolvingTypesonPromise, type);\n            }\n\n            if (runObserver) {\n              runObserver({\n                replacing: true\n              });\n            } // Now, also traverse the result in case it contains its\n            //   own types to replace\n\n\n            var replaceMethod = sync || !replacer.replaceAsync ? 'replace' : 'replaceAsync';\n            return _encapsulate(keypath, replacer[replaceMethod](value, stateObj), cyclic && 'readonly', stateObj, promisesData, resolvingTypesonPromise, type);\n          }\n        }\n\n        return value;\n      }\n\n      return promisesDataRoot.length ? sync && opts.throwOnBadSyncType ? function () {\n        throw new TypeError('Sync method requested but async result obtained');\n      }() : Promise.resolve(checkPromises(ret, promisesDataRoot)).then(finish) : !sync && opts.throwOnBadSyncType ? function () {\n        throw new TypeError('Async method requested but sync result obtained');\n      }() // If this is a synchronous request for stringification, yet\n      //   a promise is the result, we don't want to resolve leading\n      //   to an async result, so we return an array to avoid\n      //   ambiguity\n      : opts.stringification && sync ? [finish(ret)] : sync ? finish(ret) : Promise.resolve(finish(ret));\n    }\n    /**\n     * Also sync but throws on non-sync result.\n     * @param {*} obj\n     * @param {object} stateObj\n     * @param {object} opts\n     * @returns {*}\n     */\n\n  }, {\n    key: \"encapsulateSync\",\n    value: function encapsulateSync(obj, stateObj, opts) {\n      return this.encapsulate(obj, stateObj, _objectSpread2({\n        throwOnBadSyncType: true\n      }, opts, {\n        sync: true\n      }));\n    }\n    /**\n     * @param {*} obj\n     * @param {object} stateObj\n     * @param {object} opts\n     * @returns {*}\n     */\n\n  }, {\n    key: \"encapsulateAsync\",\n    value: function encapsulateAsync(obj, stateObj, opts) {\n      return this.encapsulate(obj, stateObj, _objectSpread2({\n        throwOnBadSyncType: true\n      }, opts, {\n        sync: false\n      }));\n    }\n    /**\n     * Revive an encapsulated object.\n     * This method is used internally by `Typeson.parse()`.\n     * @param {object} obj - Object to revive. If it has `$types` member, the\n     *   properties that are listed there will be replaced with its true type\n     *   instead of just plain objects.\n     * @param {object} opts\n     * @throws TypeError If mismatch between sync/async type and result\n     * @returns {Promise|*} If async, returns a Promise that resolves to `*`\n     */\n\n  }, {\n    key: \"revive\",\n    value: function revive(obj, opts) {\n      var types = obj && obj.$types; // No type info added. Revival not needed.\n\n      if (!types) {\n        return obj;\n      } // Object happened to have own `$types` property but with\n      //   no actual types, so we unescape and return that object\n\n\n      if (types === true) {\n        return obj.$;\n      }\n\n      opts = _objectSpread2({\n        sync: true\n      }, this.options, {}, opts);\n      var _opts3 = opts,\n          sync = _opts3.sync;\n      var keyPathResolutions = [];\n      var stateObj = {};\n      var ignore$Types = true; // Special when root object is not a trivial Object, it will\n      //   be encapsulated in `$`. It will also be encapsulated in\n      //   `$` if it has its own `$` property to avoid ambiguity\n\n      if (types.$ && isPlainObject(types.$)) {\n        obj = obj.$;\n        types = types.$;\n        ignore$Types = false;\n      }\n\n      var that = this;\n      /**\n       * @callback RevivalReducer\n       * @param {Any} value\n       * @param {string} type\n       * @returns {Any}\n       */\n\n      /**\n       *\n       * @param {string} type\n       * @param {Any} val\n       * @returns {[type]} [description]\n       */\n\n      function executeReviver(type, val) {\n        var _ref2 = that.revivers[type] || [],\n            _ref3 = _slicedToArray(_ref2, 1),\n            reviver = _ref3[0];\n\n        if (!reviver) {\n          throw new Error('Unregistered type: ' + type);\n        } // Only `sync` expected here, as problematic async would\n        //  be missing both `reviver` and `reviverAsync`, and\n        //  encapsulation shouldn't have added types, so\n        //  should have made an early exit\n\n\n        if (sync && !('revive' in reviver)) {\n          // Just return value as is\n          return val;\n        }\n\n        return reviver[sync && reviver.revive ? 'revive' : !sync && reviver.reviveAsync ? 'reviveAsync' : 'revive'](val, stateObj);\n      }\n      /**\n       *\n       * @returns {void|TypesonPromise<void>}\n       */\n\n\n      function revivePlainObjects() {\n        // const references = [];\n        // const reviveTypes = [];\n        var plainObjectTypes = [];\n        Object.entries(types).forEach(function (_ref4) {\n          var _ref5 = _slicedToArray(_ref4, 2),\n              keypath = _ref5[0],\n              type = _ref5[1];\n\n          if (type === '#') {\n            /*\n            references.push({\n                keypath,\n                reference: getByKeyPath(obj, keypath)\n            });\n            */\n            return;\n          }\n\n          [].concat(type).forEach(function (type) {\n            var _ref6 = that.revivers[type] || [null, {}],\n                _ref7 = _slicedToArray(_ref6, 2),\n                plain = _ref7[1].plain;\n\n            if (!plain) {\n              // reviveTypes.push({keypath, type});\n              return;\n            }\n\n            plainObjectTypes.push({\n              keypath: keypath,\n              type: type\n            });\n            delete types[keypath]; // Avoid repeating\n          });\n        });\n\n        if (!plainObjectTypes.length) {\n          return undefined;\n        } // console.log(plainObjectTypes.sort(nestedPathsFirst));\n\n        /**\n        * @typedef {PlainObject} PlainObjectType\n        * @property {string} keypath\n        * @property {string} type\n        */\n\n\n        return plainObjectTypes.sort(nestedPathsFirst).reduce(function reducer(possibleTypesonPromise, _ref8) {\n          var keypath = _ref8.keypath,\n              type = _ref8.type;\n\n          if (isThenable(possibleTypesonPromise)) {\n            return possibleTypesonPromise.then(function (val) {\n              return reducer(val, {\n                keypath: keypath,\n                type: type\n              });\n            });\n          } // console.log('obj', JSON.stringify(keypath), obj);\n\n\n          var val = getByKeyPath(obj, keypath);\n          val = executeReviver(type, val);\n\n          if (hasConstructorOf(val, TypesonPromise)) {\n            return val.then(function (v) {\n              var newVal = setAtKeyPath(obj, keypath, v);\n\n              if (newVal === v) {\n                obj = newVal;\n              }\n\n              return undefined;\n            });\n          }\n\n          var newVal = setAtKeyPath(obj, keypath, val);\n\n          if (newVal === val) {\n            obj = newVal;\n          }\n\n          return undefined;\n        }, undefined // This argument must be explicit\n        ); // references.forEach(({keypath, reference}) => {});\n        // reviveTypes.sort(nestedPathsFirst).forEach(() => {});\n      }\n\n      var revivalPromises = [];\n      /**\n       *\n       * @param {string} keypath\n       * @param {Any} value\n       * @param {?(Array|object)} target\n       * @param {Array|object} [clone]\n       * @param {string} [key]\n       * @returns {Any}\n       */\n\n      function _revive(keypath, value, target, clone, key) {\n        if (ignore$Types && keypath === '$types') {\n          return undefined;\n        }\n\n        var type = types[keypath];\n        var isArr = isArray(value);\n\n        if (isArr || isPlainObject(value)) {\n          var _clone = isArr ? new Array(value.length) : {}; // Iterate object or array\n\n\n          keys(value).forEach(function (k) {\n            var val = _revive(keypath + (keypath ? '.' : '') + escapeKeyPathComponent(k), value[k], target || _clone, _clone, k);\n\n            var set = function set(v) {\n              if (hasConstructorOf(v, Undefined)) {\n                _clone[k] = undefined;\n              } else if (v !== undefined) {\n                _clone[k] = v;\n              }\n\n              return v;\n            };\n\n            if (hasConstructorOf(val, TypesonPromise)) {\n              revivalPromises.push(val.then(function (ret) {\n                return set(ret);\n              }));\n            } else {\n              set(val);\n            }\n          });\n          value = _clone; // Try to resolve cyclic reference as soon as available\n\n          while (keyPathResolutions.length) {\n            var _keyPathResolutions$ = _slicedToArray(keyPathResolutions[0], 4),\n                _target = _keyPathResolutions$[0],\n                keyPath = _keyPathResolutions$[1],\n                _clone2 = _keyPathResolutions$[2],\n                k = _keyPathResolutions$[3];\n\n            var val = getByKeyPath(_target, keyPath); // Typeson.Undefined not expected here as not cyclic or\n            //   `undefined`\n\n            if (val !== undefined) {\n              _clone2[k] = val;\n            } else {\n              break;\n            }\n\n            keyPathResolutions.splice(0, 1);\n          }\n        }\n\n        if (!type) {\n          return value;\n        }\n\n        if (type === '#') {\n          var _ret = getByKeyPath(target, value.slice(1));\n\n          if (_ret === undefined) {\n            // Cyclic reference not yet available\n            keyPathResolutions.push([target, value.slice(1), clone, key]);\n          }\n\n          return _ret;\n        } // `type` can be an array here\n\n\n        return [].concat(type).reduce(function reducer(val, typ) {\n          if (hasConstructorOf(val, TypesonPromise)) {\n            return val.then(function (v) {\n              // TypesonPromise here too\n              return reducer(v, typ);\n            });\n          }\n\n          return executeReviver(typ, val);\n        }, value);\n      }\n      /**\n       *\n       * @param {Any} retrn\n       * @returns {undefined|Any}\n       */\n\n\n      function checkUndefined(retrn) {\n        return hasConstructorOf(retrn, Undefined) ? undefined : retrn;\n      }\n\n      var possibleTypesonPromise = revivePlainObjects();\n      var ret;\n\n      if (hasConstructorOf(possibleTypesonPromise, TypesonPromise)) {\n        ret = possibleTypesonPromise.then(function () {\n          return obj;\n        });\n      } else {\n        ret = _revive('', obj, null);\n\n        if (revivalPromises.length) {\n          // Ensure children resolved\n          ret = TypesonPromise.resolve(ret).then(function (r) {\n            return TypesonPromise.all([// May be a TypesonPromise or not\n            r].concat(revivalPromises));\n          }).then(function (_ref9) {\n            var _ref10 = _slicedToArray(_ref9, 1),\n                r = _ref10[0];\n\n            return r;\n          });\n        }\n      }\n\n      return isThenable(ret) ? sync && opts.throwOnBadSyncType ? function () {\n        throw new TypeError('Sync method requested but async result obtained');\n      }() : hasConstructorOf(ret, TypesonPromise) ? ret.p.then(checkUndefined) : ret : !sync && opts.throwOnBadSyncType ? function () {\n        throw new TypeError('Async method requested but sync result obtained');\n      }() : sync ? checkUndefined(ret) : Promise.resolve(checkUndefined(ret));\n    }\n    /**\n     * Also sync but throws on non-sync result.\n     * @param {Any} obj\n     * @param {object} opts\n     * @returns {Any}\n     */\n\n  }, {\n    key: \"reviveSync\",\n    value: function reviveSync(obj, opts) {\n      return this.revive(obj, _objectSpread2({\n        throwOnBadSyncType: true\n      }, opts, {\n        sync: true\n      }));\n    }\n    /**\n    * @param {Any} obj\n    * @param {object} opts\n    * @returns {Promise} Resolves to `*`\n    */\n\n  }, {\n    key: \"reviveAsync\",\n    value: function reviveAsync(obj, opts) {\n      return this.revive(obj, _objectSpread2({\n        throwOnBadSyncType: true\n      }, opts, {\n        sync: false\n      }));\n    }\n    /**\n     * Register types.\n     * For examples on how to use this method, see\n     *   {@link https://github.com/dfahlander/typeson-registry/tree/master/types}.\n     * @param {object.<string,Function[]>[]} typeSpecSets - Types and\n     *   their functions [test, encapsulate, revive];\n     * @param {object} opts\n     * @returns {Typeson}\n     */\n\n  }, {\n    key: \"register\",\n    value: function register(typeSpecSets, opts) {\n      opts = opts || {};\n      [].concat(typeSpecSets).forEach(function R(typeSpec) {\n        var _this = this;\n\n        // Allow arrays of arrays of arrays...\n        if (isArray(typeSpec)) {\n          return typeSpec.map(function (typSpec) {\n            return R.call(_this, typSpec);\n          });\n        }\n\n        typeSpec && keys(typeSpec).forEach(function (typeId) {\n          if (typeId === '#') {\n            throw new TypeError('# cannot be used as a type name as it is reserved ' + 'for cyclic objects');\n          } else if (Typeson.JSON_TYPES.includes(typeId)) {\n            throw new TypeError('Plain JSON object types are reserved as type names');\n          }\n\n          var spec = typeSpec[typeId];\n          var replacers = spec && spec.testPlainObjects ? this.plainObjectReplacers : this.nonplainObjectReplacers;\n          var existingReplacer = replacers.filter(function (r) {\n            return r.type === typeId;\n          });\n\n          if (existingReplacer.length) {\n            // Remove existing spec and replace with this one.\n            replacers.splice(replacers.indexOf(existingReplacer[0]), 1);\n            delete this.revivers[typeId];\n            delete this.types[typeId];\n          }\n\n          if (typeof spec === 'function') {\n            // Support registering just a class without replacer/reviver\n            var Class = spec;\n            spec = {\n              test: function test(x) {\n                return x && x.constructor === Class;\n              },\n              replace: function replace(x) {\n                return _objectSpread2({}, x);\n              },\n              revive: function revive(x) {\n                return Object.assign(Object.create(Class.prototype), x);\n              }\n            };\n          } else if (isArray(spec)) {\n            var _spec = spec,\n                _spec2 = _slicedToArray(_spec, 3),\n                test = _spec2[0],\n                replace = _spec2[1],\n                revive = _spec2[2];\n\n            spec = {\n              test: test,\n              replace: replace,\n              revive: revive\n            };\n          }\n\n          if (!spec || !spec.test) {\n            return;\n          }\n\n          var replacerObj = {\n            type: typeId,\n            test: spec.test.bind(spec)\n          };\n\n          if (spec.replace) {\n            replacerObj.replace = spec.replace.bind(spec);\n          }\n\n          if (spec.replaceAsync) {\n            replacerObj.replaceAsync = spec.replaceAsync.bind(spec);\n          }\n\n          var start = typeof opts.fallback === 'number' ? opts.fallback : opts.fallback ? 0 : Infinity;\n\n          if (spec.testPlainObjects) {\n            this.plainObjectReplacers.splice(start, 0, replacerObj);\n          } else {\n            this.nonplainObjectReplacers.splice(start, 0, replacerObj);\n          } // Todo: We might consider a testAsync type\n\n\n          if (spec.revive || spec.reviveAsync) {\n            var reviverObj = {};\n\n            if (spec.revive) {\n              reviverObj.revive = spec.revive.bind(spec);\n            }\n\n            if (spec.reviveAsync) {\n              reviverObj.reviveAsync = spec.reviveAsync.bind(spec);\n            }\n\n            this.revivers[typeId] = [reviverObj, {\n              plain: spec.testPlainObjects\n            }];\n          } // Record to be retrieved via public types property.\n\n\n          this.types[typeId] = spec;\n        }, this);\n      }, this);\n      return this;\n    }\n  }]);\n\n  return Typeson;\n}();\n/**\n * We keep this function minimized so if using two instances of this\n * library, where one is minimized and one is not, it will still work\n * with `hasConstructorOf`.\n * @class\n */\n\n\nvar Undefined = function Undefined() {\n  _classCallCheck(this, Undefined);\n}; // eslint-disable-line space-before-blocks\n\n\nUndefined.__typeson__type__ = 'TypesonUndefined'; // The following provide classes meant to avoid clashes with other values\n// To insist `undefined` should be added\n\nTypeson.Undefined = Undefined; // To support async encapsulation/stringification\n\nTypeson.Promise = TypesonPromise; // Some fundamental type-checking utilities\n\nTypeson.isThenable = isThenable;\nTypeson.toStringTag = toStringTag;\nTypeson.hasConstructorOf = hasConstructorOf;\nTypeson.isObject = isObject;\nTypeson.isPlainObject = isPlainObject;\nTypeson.isUserObject = isUserObject;\nTypeson.escapeKeyPathComponent = escapeKeyPathComponent;\nTypeson.unescapeKeyPathComponent = unescapeKeyPathComponent;\nTypeson.getByKeyPath = getByKeyPath;\nTypeson.getJSONType = getJSONType;\nTypeson.JSON_TYPES = ['null', 'boolean', 'number', 'string', 'array', 'object'];\n\nexport default Typeson;\n","/**\n * Not currently in use internally, but provided for parity.\n * @param {ArrayBuffer} buf\n * @returns {Uint8Array}\n */\nfunction arraybuffer2string (buf) {\n    return new Uint8Array(buf).reduce(\n        (s, byte) => s + String.fromCharCode(byte), ''\n    );\n}\n\n/**\n *\n * @param {string} str\n * @returns {ArrayBuffer}\n */\nfunction string2arraybuffer (str) {\n    /*\n    // UTF-8 approaches\n    const utf8 = unescape(encodeURIComponent(str));\n    const arr = new Uint8Array(utf8.length);\n    for (let i = 0; i < utf8.length; i++) {\n        arr[i] = utf8.charCodeAt(i);\n    }\n    return arr.buffer;\n\n    const utf8 = [];\n    for (let i = 0; i < str.length; i++) {\n        let charcode = str.charCodeAt(i);\n        if (charcode < 0x80) utf8.push(charcode);\n        else if (charcode < 0x800) {\n            utf8.push(0xc0 | (charcode >> 6),\n                0x80 | (charcode & 0x3f));\n        } else if (charcode < 0xd800 || charcode >= 0xe000) {\n            utf8.push(0xe0 | (charcode >> 12),\n                0x80 | ((charcode >> 6) & 0x3f),\n                0x80 | (charcode & 0x3f));\n        // surrogate pair\n        } else {\n            i++;\n            // UTF-16 encodes 0x10000-0x10FFFF by\n            // subtracting 0x10000 and splitting the\n            // 20 bits of 0x0-0xFFFFF into two halves\n            charcode = 0x10000 + (((charcode & 0x3ff) << 10) |\n                (str.charCodeAt(i) & 0x3ff));\n            utf8.push(0xf0 | (charcode >> 18),\n                0x80 | ((charcode >> 12) & 0x3f),\n                0x80 | ((charcode >> 6) & 0x3f),\n                0x80 | (charcode & 0x3f));\n        }\n    }\n    return utf8;\n    */\n    /*\n    // Working UTF-16 options (equivalents)\n    const buf = new ArrayBuffer(str.length * 2); // 2 bytes for each char\n    const bufView = new Uint16Array(buf);\n    for (let i = 0, strLen = str.length; i < strLen; i++) {\n        bufView[i] = str.charCodeAt(i);\n    }\n    return buf;\n    */\n\n    const array = new Uint8Array(str.length);\n    for (let i = 0; i < str.length; i++) {\n        array[i] = str.charCodeAt(i); // & 0xff;\n    }\n    return array.buffer;\n}\nexport {arraybuffer2string, string2arraybuffer};\n","import Typeson from 'typeson';\nimport file from './file.js';\n\nconst filelist = {\n    file: file.file,\n    filelist: {\n        test (x) { return Typeson.toStringTag(x) === 'FileList'; },\n        replace (fl) {\n            const arr = [];\n            for (let i = 0; i < fl.length; i++) {\n                arr[i] = fl.item(i);\n            }\n            return arr;\n        },\n        revive (o) {\n            class FileList {\n                constructor () {\n                    // eslint-disable-next-line prefer-rest-params\n                    this._files = arguments[0];\n                    this.length = this._files.length;\n                }\n                item (index) {\n                    return this._files[index];\n                }\n                // eslint-disable-next-line class-methods-use-this\n                get [Symbol.toStringTag] () {\n                    return 'FileList';\n                }\n            }\n            return new FileList(o);\n        }\n    }\n};\n\nexport default filelist;\n","/* globals XMLHttpRequest, File, FileReader */\nimport Typeson from 'typeson';\nimport {string2arraybuffer} from '../utils/stringArrayBuffer.js';\n\nconst file = {\n    file: {\n        test (x) { return Typeson.toStringTag(x) === 'File'; },\n        replace (f) { // Sync\n            const req = new XMLHttpRequest();\n            req.overrideMimeType('text/plain; charset=x-user-defined');\n            // eslint-disable-next-line max-len\n            // eslint-disable-next-line node/no-unsupported-features/node-builtins\n            req.open('GET', URL.createObjectURL(f), false); // Sync\n            req.send();\n\n            // Seems not feasible to accurately simulate\n            /* istanbul ignore next */\n            if (req.status !== 200 && req.status !== 0) {\n                throw new Error('Bad File access: ' + req.status);\n            }\n            return {\n                type: f.type,\n                stringContents: req.responseText,\n                name: f.name,\n                lastModified: f.lastModified\n            };\n        },\n        revive ({name, type, stringContents, lastModified}) {\n            return new File([string2arraybuffer(stringContents)], name, {\n                type,\n                lastModified\n            });\n        },\n        replaceAsync (f) {\n            return new Typeson.Promise(function (resolve, reject) {\n                /*\n                if (f.isClosed) { // On MDN, but not in https://w3c.github.io/FileAPI/#dfn-Blob\n                    reject(new Error('The File is closed'));\n                    return;\n                }\n                */\n                const reader = new FileReader();\n                reader.addEventListener('load', function () {\n                    resolve({\n                        type: f.type,\n                        stringContents: reader.result,\n                        name: f.name,\n                        lastModified: f.lastModified\n                    });\n                });\n                // Seems not feasible to accurately simulate\n                /* istanbul ignore next */\n                reader.addEventListener('error', function () {\n                    reject(reader.error);\n                });\n                reader.readAsBinaryString(f);\n            });\n        }\n    }\n};\n\nexport default file;\n"],"names":["_typeof","obj","Symbol","_typeof2","iterator","constructor","prototype","asyncGeneratorStep","gen","resolve","reject","_next","_throw","key","arg","info","value","error","done","Promise","then","_asyncToGenerator","fn","self","this","args","arguments","apply","err","undefined","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","_defineProperty","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","push","_objectSpread2","source","forEach","getOwnPropertyDescriptors","defineProperties","_slicedToArray","arr","_arrayWithHoles","Array","isArray","_iterableToArrayLimit","toString","call","_arr","_n","_d","_e","_s","_i","next","_nonIterableRest","_toConsumableArray","_arrayWithoutHoles","arr2","_iterableToArray","iter","from","_nonIterableSpread","TypesonPromise","f","p","__typeson__type__","toStringTag","onFulfilled","onRejected","_this","typesonResolve","typesonReject","res","v","meth","promArr","map","prom","toStr","hasOwn","hasOwnProperty","getProto","getPrototypeOf","fnToString","isThenable","catchCheck","isObject","val","slice","hasConstructorOf","a","b","proto","Ctor","isPlainObject","escapeKeyPathComponent","keyPathComponent","replace","unescapeKeyPathComponent","getByKeyPath","keyPath","period","indexOf","innerObj","setAtKeyPath","hasOwn$1","internalStateObjPropsToIgnore","nestedPathsFirst","keypath","as","match","bs","Typeson","options","plainObjectReplacers","nonplainObjectReplacers","revivers","types","_createClass","protoProps","staticProps","stringify","replacer","space","opts","stringification","encapsulated","encapsulate","JSON","stringifySync","throwOnBadSyncType","sync","stringifyAsync","parse","text","reviver","revive","parseSync","parseAsync","specialTypeNames","stateObj","returnTypeNames","rootTypeName","iterateNone","that","refObjs","refKeys","promisesDataRoot","cyclic","encapsulateObserver","ret","_encapsulate","finish","typeNames","values","getJSONType","Set","$types","$","checkPromises","_x","_x2","_checkPromises","regeneratorRuntime","mark","_callee2","promisesData","promResults","wrap","_callee2$","_context2","prev","all","pd","sent","_ref","_callee","promResult","newPromisesData","_promisesData$splice","_promisesData$splice2","prData","_prData","parentObj","detectedType","encaps","isTypesonPromise","encaps2","_callee$","_context","splice","abrupt","stop","_x3","_adaptBuiltinStateObjectProperties","ownKeysObj","cb","assign","vals","prop","tmp","resolvingTypesonPromise","observerData","$typeof","runObserver","type","awaitingTypesonPromise","includes","isNaN","Infinity","replaced","iterateIn","iterateUnsetNumeric","refIndex","cyclicKeypath","clone","isPlainObj","isArr","ArrayBuffer","addLength","_loop","kp","Boolean","endIterateIn","end","endIterateOwn","vl","_loop2","endIterateUnsetNumeric","plainObject","replacers","test","existing","concat","replaceAsync","replacing","typeDetected","encapsulateSync","encapsulateAsync","keyPathResolutions","ignore$Types","executeReviver","Error","reviveAsync","revivalPromises","checkUndefined","retrn","Undefined","possibleTypesonPromise","revivePlainObjects","plainObjectTypes","entries","_ref4","_ref5","plain","sort","reduce","reducer","_ref8","newVal","_revive","_clone","k","set","_keyPathResolutions$","_target","_clone2","_ret","typ","r","_ref9","reviveSync","register","typeSpecSets","R","typeSpec","typSpec","typeId","JSON_TYPES","spec","testPlainObjects","existingReplacer","Class","x","create","_spec2","replacerObj","bind","start","fallback","reviverObj","string2arraybuffer","str","array","Uint8Array","charCodeAt","buffer","isUserObject","file","req","XMLHttpRequest","overrideMimeType","open","URL","createObjectURL","send","status","stringContents","responseText","name","lastModified","File","reader","FileReader","addEventListener","result","readAsBinaryString","filelist","fl","item","o","_files","index"],"mappings":"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"}